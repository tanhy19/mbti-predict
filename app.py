# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zm8Sr0enx1psbsDK5F8R4InMpnL3q34f
"""

import streamlit as st
import joblib
import pandas as pd
from collections import Counter
from preprocess import preprocess  # Your preprocessing function

# ---------------------------
# Load models and vectorizer
# ---------------------------
vectorizer = joblib.load('models/vectorizer.pkl')

models = {
    "Naive Bayes": {
        'I/E': joblib.load('models/naivebayes_ie.pkl'),
        'N/S': joblib.load('models/naivebayes_ns.pkl'),
        'F/T': joblib.load('models/naivebayes_ft.pkl'),
        'P/J': joblib.load('models/naivebayes_pj.pkl')
    },
    "SVM": {
        'I/E': joblib.load('models/svm_ie.pkl'),
        'N/S': joblib.load('models/svm_ns.pkl'),
        'F/T': joblib.load('models/svm_ft.pkl'),
        'P/J': joblib.load('models/svm_pj.pkl')
    },
    "Random Forest": {
        'I/E': joblib.load('models/randomforest_ie.pkl'),
        'N/S': joblib.load('models/randomforest_ns.pkl'),
        'F/T': joblib.load('models/randomforest_ft.pkl'),
        'P/J': joblib.load('models/randomforest_pj.pkl')
    }
}

mbti_maps = {
    'I/E': {0: 'I', 1: 'E'},
    'N/S': {0: 'N', 1: 'S'},
    'F/T': {0: 'F', 1: 'T'},
    'P/J': {0: 'P', 1: 'J'}
}

# ---------------------------
# Streamlit UI
# ---------------------------
st.title("üìù MBTI Predictor")
st.write("Enter a sentence, and see MBTI predictions from Naive Bayes, SVM, Random Forest, and ensemble.")

sample_text = st.text_area("Enter your text here:", height=120)

if st.button("Predict MBTI"):
    if not sample_text or len(sample_text.split()) < 3:
        st.warning("‚ö†Ô∏è Please enter a longer, meaningful sentence.")
    else:
        X_sample = vectorizer.transform(preprocess([sample_text])).toarray()

        results = []
        ensemble = []

        # Predict each MBTI component for all models
        for model_name, model_set in models.items():
            pred_letters = []
            for comp, model in model_set.items():
                pred_num = model.predict(X_sample)[0]
                letter = mbti_maps[comp][pred_num]
                pred_letters.append(letter)
            full_mbti = "".join(pred_letters)
            results.append([model_name] + pred_letters + [full_mbti])
            ensemble.append(pred_letters)

        # Compute ensemble (majority vote per component)
        ensemble_mbti = []
        for i in range(4):
            comp_votes = [vote[i] for vote in ensemble]
            most_common = Counter(comp_votes).most_common(1)[0][0]
            ensemble_mbti.append(most_common)
        ensemble_full = "".join(ensemble_mbti)
        results.append(["Ensemble"] + ensemble_mbti + [ensemble_full])

        # Display results in a table
        df_results = pd.DataFrame(
            results,
            columns=["Model", "I/E", "N/S", "F/T", "P/J", "Full MBTI"]
        )
        st.table(df_results)